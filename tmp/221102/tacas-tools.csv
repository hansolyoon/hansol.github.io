ID,TYPE,NAME,ABSTRACT,PREFERENCE,
,,,,,
9,DEMO,PyLTA: A Verification Tool for Parameterized Distributed Algorithms,"We present the tool PyLTA, which can model check parameterized distributed algorithms against LTL specifications. The parameters typically include the number of processes and a bound on faulty processes, and the considered algorithms are round-based and either synchronous or asynchronous.",No,Yes
,,,,,
20,DEMO,Eclipse ESCET™: The Eclipse Supervisory Control Engineering Toolkit,"The Eclipse Supervisory Control Engineering Toolkit (ESCET™) is an open-source project to provide a model-based approach and toolkit for developing supervisory controllers, targeting their entire engineering process. It supports synthesis-based engineering of supervisory controllers for discrete-event systems, combining model-based engineering with computer-aided design to automatically generate correct-by-construction controllers. At its heart is supervisory controller synthesis, a formal technique for the automatic derivation of supervisory controllers from the unrestricted system behavior and system requirements. Vital for the future development of these techniques and tools is the ESCET project’s open environment, allowing industry and academia to collaborate on creating an industrial-strength toolkit. We report on some crucial developments of the toolkit in the context of research projects with Rijkswaterstaat and ASML that have considerably improved its capability to deal with the complexity of real-life systems as well as its usability.",No,
,,,,,
22,DEMO,TRAIAN 3: Towards Formally Developed Formal Tools,"We present the TRAIAN 3 compiler for LNT, a formal method that combines the best features of imperative programming, functional programming, and process calculi. TRAIAN 3 is intensively used for constructing compilers and verification tools, paving the way for formal tools themselves developed using formal methods.",No,
,,,,,
44,DEMO,CoqCryptoLine: A Verified Model Checker with Certified Results,We present the verified model checker CoqCryptoLine for cryptographic programs with certified verification results. The CoqCryptoLine verification algorithm consists of two reductions. The algebraic reduction transforms to the root entailment problem; and the bit vector reduction transforms to the SMT QF_BV problem. We specify and verify both reductions formally using Coq with Ssreflect. The CoqCryptoLine program is built on the OCaml programs extracted from verified reductions. CoqCryptoLine moreover employs certified techniques for solving the algebra and logic problems. We evaluate CoqCryptoLine on cryptographic programs from industrial security libraries.,No,
,,,,,
51,DEMO,WASIM: A Word-level Abstract Symbolic Simulation Framework for Hardware Formal Verification,"This paper demonstrates the design and usage of WASIM, a word-level abstract symbolic simulation framework with pluggable abstraction/refinement functions. WASIM is useful in the formal verification of functional properties on register-transfer level (RTL) hardware designs. Users can control the symbolic simulation process and tune the level of abstraction by interacting with WASIM through its Python API. WASIM can be used to directly check formal properties on symbolic traces or to extract useful fragments from symbolic representations to construct safe inductive invariants as a correctness certificate. We demonstrate the utility of WASIM on the verification of two pipelined hardware designs. WASIM and the case studies will be made available under open-source license after publication.",No,No
,,,,,
76,DEMO,pymwp: A Tool for Guaranteeing Complexity Bounds for C Programs,"Complexity analysis offers assurance of program’s runtime behavior, but large classes of programs remain unanalyzable by existing automated techniques. The mwp-flow analysis sidesteps many difficulties shared by existing approaches, and offers interesting features, such as compositionality, multivariate bounds, and applicability to non-terminating programs. It analyzes resource usage and determines if a program’s variables growth rates are no more than polynomially related to their inputs sizes. This sound calculus, however, is computationally expensive to manipulate, and provides no feedback if the program does not have polynomial bounds. Those two defaults were addressed in a previous work, and prepared for the tool we present here: pymwp, a static complexity analyzer for C programs based on our improved mwp-flow analysis.",No,
,,,,,
91,DEMO,Iltis: Learning Logic in the Web,"The Iltis project provides an interactive, web-based system for teaching the foundations of formal methods.It is designed with the objective to allow for simple inclusion of new educational tasks; to pipeline such tasks into more complex exercises; and to allow simple inclusion and cascading of feedback mechanisms. Currently, exercises for many typical automated reasoning workflows for propositional logic, modal logic, and some parts of first-order logic are covered.Recently, Iltis has reached a level of maturity where large parts of introductory logic courses can be supplemented with interactive exercises. Sample interactive course material has been designed and used in courses over the last years, many of them with more than 300 students.",No,
,,,,,
96,DEMO,ParaGnosis: A Tool for Parallel Knowledge Compilation,"ParaGnos is an open-source tool that supports inference queries on Bayesian networks through weighted model counting. In the knowledge compilation step, the input Bayesian network is encoded as propositional logic and then compiled into a knowledge base in decision diagram representation. The tool supports various diagram formats, including the Weighted-Positive Binary Decision Diagram (WPBDD) which can concisely represent discrete probability distributions.Once compiled, the probabilistic knowledge base can be queried in the inference step. To efficiently implement both steps, ParaGnos uses simulated annealing to split the knowledge base into a number of partitions. This further reduces the decision diagram size and crucially enables parallelism in both the compilation and the inference steps. Experiments demonstrated that this partitioned approach, in combination with the WPBDD representation, can outperform other approaches in the knowledge compilation step, at the cost of slightly more expensive inference queries.",No,
,,,,,
101,DEMO,Property-Based Conjecturing for Automated Induction in Isabelle/HOL,"Proof by induction plays a central role in formal verification. However, its automation remains as a formidable challenge in Computer Science. To solve inductive problems, human engineers often have to provide auxiliary lemmas manually. We automate this laborious process with property-based conjecturing, a novel approach to generate auxiliary lemmas and use them to prove final goals. Our evaluation shows that our working prototype, PBC, achieved 40 percentage point improvement of success rates for problems at intermediate difficulty level.",No,
,,,,,
142,DEMO,"Multiparty Session Typing in Java, Deductively","Multiparty session typing (MPST) is a method to automatically prove safety and liveness of protocol implementations relative to specifications. We present a new tool to apply the MPST method in combination with Java. The checks performed using our tool are purely static (all errors are reported early at compile-time) and resource-efficient (near-zero cost abstractions at run-time), thereby addressing two issues of existing tools. Instead of building a new static analyser from scratch, we leverage a state-of-the-art deductive verifier for Java, namely VerCors. The combination of MPST and deductive verification is largely unexplored territory and, thus, a novel methodological contribution.",No,No
,,,,,
146,DEMO,FuzzBtor2: A Random Generator of Word-Level Model Checking Problems in Btor2 Format,"We present FuzzBtor2, a fuzzer to generate random word-level model checking problems in Btor2 format. Btor2 is one of the mainstream input formats for word-level hardware model checking and was used in the most recent hardware model checking competition. Compared to bit-level one, word-level model checking is a more complex research field at an earlier stage of development. Therefore, it is necessary to develop a tool that can produce a massive of Btor2 benchmarks to test either existing or under-developed word-level model checkers. To evaluate the practicality of FuzzBtor2, we tested the state-of-the-art word-level model checkers AVR and Pono with the generated benchmarks. Experimental results show that both tools are buggy and not mature enough, which reflects the practical value of FuzzBtor2.",No,
,,,,,
153,DEMO,Tolerange: Quantifying Fault Masking in Stochastic Systems,"In this paper we present Tolerange, a tool tailored for measuring the masking fault-tolerance provided by stochastic systems. It allows one to take into account both the probabilities of faults and also the possible use of randomized algorithms. The tool is based on concepts coming from game theory. Roughly speaking, a fault-tolerant stochastic system is formalized as a stochastic game played by two players: a fault- tolerant version of the system that intends to maximize the expected number of “milestones” achieved during the execution of the system, and the environment that tries to minimize that value, for doing that the environment can plays “faults” when possible. Tolerange takes as input a nominal model and its fault-tolerant implementation written in a Prism-like notation, and produces as output the expected accumulated milestones that the implementation is able to preserve for the considered faults, this is a value in the interval [0,∞). We have used the tool to measure the probabilistic masking fault-tolerance of common examples of fault-tolerance.",No,
,,,,,
158,DEMO,ppLTLTT: Temporal testing for pure-past linear temporal logic formulae,"This paper presents ppLTLTT, a tool for translating pure-past linear temporal logic formulae into temporal testers in the form of automata. We show how ppLTLTT can be used to easily extend existing LTL-based tools, such as LTL-to-automata translators and reactive synthesis tools, to support a richer input language. Namely, with ppLTLTT, tools that accept LTL input are also made to handle pure-past LTL as atomic formulae. While the addition of past operators does not increase the expressive power of LTL, it opens up the possibility of writing more intuitive and succinct specifications. We illustrate this intended use of ppLTLTT for Slugs, Strix and Spot’s command line tool LTL2TGBA by describing three corresponding wrapper tools pSlugs, pStrix and pLTL2TGBA, that all leverage ppLTLTT. All three wrapper tools are designed to seamlessly fit this paradigm, by staying as close to the respective syntax of each underlying tool as possible.",No,Yes
,,,,,
160,DEMO,GPUexplore 3.0: GPU Accelerated State Space Exploration for Concurrent Systems with Data,"GPUexplore 3.0 is an explicit state space exploration tool that runs entirely on a graphics processing unit (GPU), and supports models of concurrent systems with data variables. We discuss its workflow and modelling language, present several design decisions regarding work distribution and retrieval, and experimentally evaluate the impact of those decisions. It currently checks for deadlocks, with verification of temporal logic formulae planned for the near future.",No,
,,,,,
171,DEMO,"MAZACOTE: Automatic Unit Test Generation, Execution and Reporting for Model-Based Aerospace Embedded Software","We present our tool for introducing automatic test case generation and execution in the development workflow of an aerospace company. Currently our industrial partner invests significant time and human resources in the manual generation of test cases, and this task is left to experts in the domain. Thanks to MAZACOTE, which is based on the KLEE symbolic execution engine, we can fully automate this task and achieve full coverage (i.e. 100% of reachable code) considering lines and branches.",No,
,,,,,
3,TOOL,Extending a High-Performance Prover to Higher-Order Logic,"Most users of proof assistants want more proof automation. Some proof assistants discharge goals by translating them to first-order logic and invoking an efficient prover on them, but much is lost in translation. Instead, we propose to extend first-order provers with native support for higher-order features. Building on our extension of E to λ-free higher-order logic, we extend E to full higher-order logic. The result is the strongest prover on benchmarks exported from a proof assistant.",No,
,,,,,
6,CASE,Verifying Learning-Based Robotic Navigation Systems: A Case Study,"Deep reinforcement learning (DRL) has become a dominant deep-learning paradigm for tasks where complex policies are learned within reactive systems. Unfortunately, these policies are known to be susceptible to bugs. Despite significant progress in DNN verification, there has been little work demonstrating the use of modern verification tools on real, DRL-controlled, systems. In this case-study paper, we attempt to begin bridging this gap, and focus on the important task of mapless robotic navigation - a classic robotics problem, in which a robot, usually controlled by a DRL agent, needs to efficiently and safely navigate through an unknown arena towards a desired target. We demonstrate how modern verification engines can be used for effective model selection, i.e., the process of selecting the best available policy for the robot in question from a pool of candidate policies. Specifically, we use verification to detect and rule out policies that may demonstrate suboptimal behavior, such as collisions and infinite loops. We also apply verification to identify models with overly conservative behavior, thus allowing users to choose superior policies, which are better at finding shorter paths to a target. To validate our work, we conducted extensive experiments on an actual robot, and confirmed that the suboptimal policies detected by our method were indeed flawed. We also demonstrate the superiority of our verification-driven approach over state-of-the-art, gradient attacks. Our work is the first to demonstrate the usefulness of DNN verification in identifying and filtering out suboptimal DRL policies in real-world robots; and we believe that the methods presented here are applicable to a wide range of systems that incorporate deep-learning-based agents.",No,Maybe
,,,,,
17,TOOL,ALMA: Automata Learner using Modulo 2 Multiplicity Automata,"We present ALMA (Automata Learner using modulo 2 Multiplicity Automata), a Java-based tool that can learn any automaton accepting regular languages of finite or infinite words that has a defined membership query function. Users can either pass as input their own membership query function, or use the predefined membership query functions for modulo 2 multiplicity automata and non-deterministic Büchi automata. While learning, ALMA can output the state of the observation table after every equivalence query, and upon termination, it can output the dimension, transition matrices, and final vector of the learned modulo 2 multiplicity automaton. Users can test whether a word is accepted by performing a membership query on the learned automaton. ALMA follows the polynomial-time learning algorithm of Beimel et. al. (Learning functions represented as multiplicity automata. J. ACM 47(3), 2000), which uses membership and equivalence queries and represents hypotheses using modulo 2 multiplicity automata. ALMA also implements a polynomial-time learning algorithm for strongly unambiguous Büchi automata by Angluin et. al. (Strongly unambiguous Büchi automata are polynomially predictable with membership queries. CSL 2020), and a minimization algorithm for modulo 2 multiplicity automata by Sakarovitch (Elements of Automata Theory. 2009).",No,
,,,,,
27,TOOL,Mining and Analysing String Constraints,"String constraint solving, and the underlying theory of word equations, are highly interesting research topics both for practitioners and theoreticians working in the wide area of satisfiability modulo theories. As string constraint solving algorithms, a.k.a. string solvers, gained a more prominent role in the formal analysis of string-heavy programs, especially in connection to symbolic code execution and security protocol verification, we can witness an ever-growing number of benchmarks collecting string solving instances from real-world applications as well as an ever-growing need for more efficient and reliable solvers, especially for the aforementioned real-world instances. Thus, it seems that the string solving area (and the developers, theoreticians, and end-users active in it) could greatly benefit from a better understanding and processing of the existing string solving benchmarks. In this context, we propose SMTQuery: an SMT-LIB benchmark analysis tool for string constraints. SMTQuery is implemented in Python 3, and offers a collection of analysis and information extraction tools for a comprehensive data base of string benchmarks (presented in SMT-LIB format), based on a novel SQL-centred language, called qlang.",No,
,,,,,
29,TOOL,VCFloat2: Floating-point error analysis in Coq,"The development of sound and efficient tools that automatically perform floating-point round-off error analysis is an active area of research with applications to embedded systems and scientific computing. In this paper we describe VCFloat2, a novel extension to the VCFloat tool for verifying floating-point C programs in Coq. Like VCFloat, VCFloat2 soundly and automatically computes round-off error bounds on floating-point expressions, but does so to higher accuracy, with better performance, and with improved modularity for interfacing with other program verification tools in Coq. We evaluate the performance of VCFloat2 using common benchmarks; compared to other state-of-the art tools, VCFloat2 computes competitive error bounds and transparent certificates that require less time for verification.",No,
,,,,,
31,TOOL,DISV: Domain Independent Semantic Validation of Data Files,"Data format specification languages such as PDF or HTML have been used extensively for exchanging structured data over the internet. While receivers of data files (e.g., PDF viewers or web browsers) per- form syntax validation of files, validating deep semantic properties has not been systematically explored in practice. However, data files that violate semantic properties may cause unintended effects on receivers, such as causing them to crash or creating security breaches, as recent at- tacks showed. We present our tool DISV (Domain Independent Semantic Validator). It includes a declarative specification language for users to specify semantic properties of a data format. It also includes a validator that takes a data file together with a property specification and checks if the file follows the specification. We demonstrate a rich variety of prop- erties that can be verified by our tool using eight case studies over three data formats. We also demonstrate that our tool can be used to detect advanced attacks on PDF documents.",No,No
,,,,,
46,CASE,Model Checking of the Equivalence of Two Terms in Free Orthomodular Lattices,"Since 1936, orthomodular lattice, one of the algebraic structures of quantum mechanics, has attracted many logicians' attention.Over its long history, various complex theorems have been manually proven. Some tools have been implemented to verify these theorems automatically by means of checking the equivalence of two terms (the word problem). However, existing tools cannot deal with terms that consist of three or more free variables.Because the number of normal forms in the free orthomodular lattice with three or more generators is infinite, even though that of two generators is only 96. To overcome this limitation,we transform the word problem into a reachability problem in model checking. Using this idea, we implement a support tool in Maude consisting of a formal specification of free orthomodular lattices and an implementation of the Folius-Holland theorem and the 96 normal forms of two generators. In Maude, the search command is used to perform the reachability analysis to deal with terms that consist of even three or more variables.Some case studies are conducted with the tool to verify various complex theorems that existing tools cannot verify.",No,
,,,,,
49,TOOL,Safety Verification of Declarative Smart Contracts,"Smart contracts manage a large number of digital assets nowadays. Bugs in these contracts have led to significant financial loss. Verifying the correctness of smart contracts is therefore an important task. This paper presents a safety verification tool DCV that targets declarative smart contracts written in DeCon, a logic-based domain-specific language for smart contract implementation and specification. DCV is sound and fully automatic. It proves safety properties by mathematical induction and can automatically infer inductive invariants without annotations from the developer. Our evaluation shows that DCV is effective in verifying smart contracts adapted from public repositories, and can verify contracts not supported by other tools. Furthermore, DCV significantly outperforms baseline tools in verification time.",No,Maybe
,,,,,
79,TOOL,Cyclone: A New Specification Language for Verifying/Testing Graph-based Structures,"Graphs can naturally capture both static and dynamic behaviours of a system. Many challenging problems can be reduced to graphs. In this paper, we present a new graph-based specification language called Cyclone. It can be used for verifying and testing graph-based models. Different from other specification languages, Cyclone provides users with a unique way for building models and specifying properties. Our preliminary evaluation shows promising results where Cyclone has a great potential in handling a variety of problems from different areas such as program verification, model checking, graph searching and hybrid systems. Further, the feedback we collect suggests that Cyclone has a good usability and is very well welcomed by students. This also opens the possibility of including Cyclone into existing CS curriculum.",No,
,,,,,
81,TOOL,"On using VeriFast, VerCors, Plural, and KeY to check object usage","Typestates are a notion of behavioral types that describe protocols for stateful objects, specifying the available methods for each state, in terms of a state machine. Usually, objects with protocols are either forced to be used in a linear way, which restricts what a programmer can do, or deductive verification is required to verify programs where these objects may be aliased. To evaluate the strengths and limitations of static verification tools for object-oriented languages in checking the correct use of shared objects with protocol, we present a survey on four tools for Java: VeriFast, VerCors, Plural, and KeY. We describe the implementation of a file reader and of a linked-list, check for each tool its ability to statically guarantee protocol compliance, as well as protocol completion, even when objects are shared in collections, and evaluate the programmer's effort in making the code acceptable to these tools.",No,
,,,,,
82,CASE,Real Relaxation of Non-Linear Integer Arithmetic for Smart Contract Verification,"The need to solve non-linear arithmetic constraints presents a major obstacle for the automatic verification of smart contracts. In this case study we investigate an approach that makes formulas in non-linear integer arithmetic easier to solve by cautiously overapproximating them in real arithmetic. We implemented our method and evaluated it on a set of industry benchmarks produced by the industrial smart contract verifier Certora Prover, as well as benchmarks from SMT-LIB. For the industry benchmarks, our method led to solving a significant number of new problems. For the SMT-LIB benchmarks, the results suggest potential directions of improvement for some solvers",No,
,,,,,
85,TOOL,Jajapy: a Learning Extension for the Model Checker Storm,"We present Jajapy, a python extension to the Storm model checker, which learns Markov models. Given a dataset, Jajapy automatically generates Markov models in Stormpy format. Currently, Jajapy supports discrete-time and continuous-time Markov chains, as well as Markov decision processes. The tool implements different learning techniques, namely the Baum-Welch algorithm and Alergia, which are suitably adapted to the different modelling formats. This paper contains a quick tour of the features of Jajapy, its architecture, and the algorithms implemented, as well as a quantitative evaluation of its performances. Finally, we compare Jajapy to AALpy, a state-of-the-art python library for learning automata. AALpy implements active learning algorithms to learn discrete-time Markov chains and Markov decision processes, while Jajapy implements passive learning approaches.",No,
,,,,,
86,TOOL,Acacia-Bonsai: A Modern Implementation of Downset-Based LTL Realizability,"We describe our implementation of downset-manipulating algorithms used to solve the realizability problem for linear temporal logic (LTL). These algorithms were introduced by Filiot et al.~in the 2010s and implemented in the tools Acacia and Acacia+ in C and Python. We identify degrees of freedom in the original algorithms and provide a complete rewriting of Acacia in C++20 articulated around genericity and leveraging modern techniques for better performance. These techniques include compile-time specialization of the algorithms, the use of SIMD registers to store vectors, and several preprocessing steps, some relying on efficient Binary Decision Diagram (BDD) libraries. We also explore different data structures to store downsets. The resulting tool is competitive against comparable modern tools.",No,
,,,,,
90,TOOL,LEGOS-A: Legal Compliance Verifier via Satisfiability Checking,"Software systems handling data are increasingly required to comply with legal properties (LPs) aimed at ensuring security and data privacy. Metric First Order Temporal Logic (MFOTL) enables the specification of data and time constraints, and thus is often used to formalize LPs. An existing bounded satisfiability checking tool LEGOS has been proposed for early stage verification of LPs on system requirements, provided both are expressible in MFOTL. While generally effective, LEGOS cannot efficiently support data constraints with aggregated values often found in finance and data privacy regulations because aggregation is not directly expressible in MFOTL. Modeling aggregated values in MFOTL with auxiliary predicates leads to complex data constraints that negatively affect the efficiency of LEGOS. Recognizing that supporting aggregation directly would ease the pain of modelling and enable optimizations by exploiting properties such as monotonicity, in this paper we present a bounded satisfiability checker that handles MFOTL extended with aggregation (MFOTL+). Our tool, LEGOS-A, is built on top of LEGOS, and further includes four optimizations to improve the efficiency of the analysis, and a web-based front-end. Evaluating LEGOS-A on 4 published case studies and 6 academic examples from various domains shows that it can handle aggregation constraints effectively and provide an up to 30 times speed-up compared to LEGOS",No,
,,,,,
92,TOOL,Formally Verified EVM Block-Optimizations,"The efficiency and the security of smart contracts (i.e., the type of programs executing on the blockchain) are their two fundamental properties, but might come at odds: the use of optimizers to enhance efficiency may introduce bugs and compromise security. Our focus is on EVM (Ethereum Virtual Machine) block-optimizations, which enhance the efficiency of jump-free blocks of opcodes by eliminating, reordering and even changing the original opcodes. We reconcile efficiency and security by providing the verification technology to formally prove the correctness of EVM block-optimizations on smart contracts using the Coq proof assistant. This amounts to the challenging problem of proving semantic equivalence of two blocks of EVM instructions, which is realized by means of three Coq components: a symbolic execution engine which can execute an EVM block and produce a resulting symbolic state; a checker of symbolic states to compare the result of symbolic execution of the two EVM blocks under comparison; and a number of simplification lemmas which transform a symbolic state into an equivalent one. Our implementation currently can verify stack-optimizations and includes also the most-used simplification lemmas. Preliminary experimental evaluation shows that we are able to automatically verify the correctness of optimizations performed by an (untrusted) SMT-based optimization tool.",No,
,,,,,
100,TOOL,A Toolkit for Automated Testing of Dafny,"Dafny is a verification-ready programming language that is executed via compilation to C# or another target language. To ensure that the compiled code exhibits the same behavior as the verified Dafny program, one needs to be able to detect differences between the two that may arise due to bugs in the compiler or the use of unverified external libraries. In this paper, we introduce a toolkit for automated testing of Dafny programs consisting of: DUnit (unit testing framework), DMock (mocking framework), and DTest (automated test generation). The main component of the toolkit, DTest, relies on both DUnit and DMock and repurposes the Dafny verifier to automatically generate test cases that achieve desired coverage. We evaluate the new toolkit in two ways. First, we use two open-source Dafny projects to demonstrate that DTest can generate unit tests with branch coverage that is comparable to the expectations developers set for manually written tests. Second, we show that our greedy approach to test generation often produces the number of tests close to the theoretical minimum. Overall, our results show that DUnit, DMock, and DTest working together are a promising toolkit for automatically generating tests for Dafny.",No,Maybe
,,,,,
102,TOOL,CoPTIC: Constraint Programming Translated Into C,"Constraint programming systems allow a diverse range of problems to be modelled and solved. Most systems require the user to learn a new constraint programming language, which presents a barrier to novice and casual users. To address this problem, we present the CoPTIC constraint programming system, which allows the user to write a model in the well-known programming language C, augmented with a simple API to support using a guess-and-check paradigm. The resulting model is at most as complex as an ordinary C program that uses naive brute force to solve the same problem.  CoPTIC uses the bounded model checker CBMC to translate the model into a SAT instance, which is solved using the SAT solver CaDiCaL. We show that, while this is less efficient than a direct translation from a dedicated constraint language into SAT, performance remains adequate for casual users. CoPTIC supports constraint satisfaction and optimisation problems, as well as enumeration of multiple solutions. After a solution has been found, CoPTIC allows the model to be run with the solution; this makes it easy to debug a model, or to print the solution in any desired format.",No,
,,,,,
107,TOOL,UpMax: User partitioning for MaxSAT,"It has been shown that Maximum Satisfiability (MaxSAT) problem instances can be effectively solved by partitioning the set of soft clauses into several disjoint sets. The partitioning methods can be based on clause weights (e.g., stratification) or based on graph representations of the formula. Afterwards, a merge procedure is applied to guarantee that an optimal solution is found.  This paper proposes a new framework called UpMax that decouples the partitioning procedure from the MaxSAT solving algorithms. As a result, new partitioning procedures can be defined independently of the MaxSAT algorithm to be used. Moreover, this decoupling also allows users that build new MaxSAT formulas to propose partition schemes based on knowledge of the problem to be solved. We illustrate this approach using several problems and show that partitioning has a large impact on the performance of unsatisfiability-based MaxSAT algorithms.",No,
,,,,,
109,TOOL,The WhyRel Prototype for Relational Verification of Pointer Programs,"Verifying relations between programs arises as a task in various contexts such as optimizing transformations, relating new versions of programs with older versions (regression verification), and noninterference. However, relational verification for programs acting on dynamically allocated mutable state is not well supported by existing tools, which provide a high level of automation at the cost of restricting the programs considered. Auto-active tools, on the other hand, require more user interaction but enable verification of a broader class of programs. This article presents WhyRel, a tool for the auto-active verification of relational properties of pointer programs based on relational region logic. WhyRel is evaluated through verification case studies, relying on SMT solvers orchestrated by the Why3 platform on which it builds. Case studies include establishing representation independence of ADTs, showing noninterference, and challenge problems from recent literature.",No,
,,,,,
111,TOOL,Algebraic Types for Contract-based Design,"Tools for designing cyber-physical systems treat models of behavior and requirements as distinct. Providing consistency checks between requirement and behavior model views can equip system modelers with a way to address increasing system complexity. We rely on representing systems-as-algebras to achieve these consistency checks and then define interfaces in strict compositional terms. Specifically, we present the algebras of behavior and contracts drawing relationships that help provide compositional verification. The result is a set of algebraic types for systems modeling to relate algebras of requirements and behaviors. In addition, we introduce contract-based design and develop in practice previously stated interface theories for contracts for the Julia programming language, which holds promise in becoming a strong contender in modeling, simulation, and testing.",No,
,,,,,
114,TOOL,Servois2: Extended Commutativity Synthesis,"Commutativity of data-structure operations is finding increasingly many applications including proof methodologies for concurrency, reductions, automated parallelization, and distributed systems. While there has been some work on automatically generating commutativity conditions through abstraction refinement, the implementation Servois was preliminary and did not explore deeper performance or practical considerations.  In this paper, we describe Servois2, a new and more performant commutativity inference tool, improving over the state-of-the-art in several dimensions. We introduce a lattice approach to predicate generation that uses semantics to filter predicates, reduce the search space, and further prune during recursion. Next, we introduce more efficient predicate selection heuristics that reduce SMT queries and employ model counting to more rapidly cover the search space. Finally, we show that predicates can be generated automatically.  We implemented Servois2 in OCaml, with added support for CVC5 and Z3. We provide an experimental validation demonstrating performance improvement from the lattice treatment (~3.13x speedup) and new heuristics (~2.90x speedup), when compared against a faithful OCaml re-implementation of Servois. We also show that our new heuristic leads to better scaling with respect to the number of predicates.",No,
,,,,,
118,TOOL,Industrial-Strength Controlled Concurrency Testing for C# Programs with Coyote,"This paper describes the design and implementation of the open-source tool Coyote for testing concurrent programs written in the C# language. Coyote provides algorithmic capabilities to explore the state-space of interleavings of a concurrent program, with deterministic repro for any bugs that it finds. Coyote encapsulates multiple ideas from the research community to offer state-of-the-art testing for C# programs, as well as an efficiently engineered solution that has been shown robust enough for industrial usage.",No,No
,,,,,
121,TOOL,Mungojerrie: Linear-Time Objectives in Model-Free Reinforcement Learning,"Mungojerrie is an extensible tool that provides a framework to translate linear-time objectives into reward for reinforcement learning (RL). The tool provides convergent RL algorithms for stochastic games, reference implementations of existing reward translations for $\omega$-regular objectives, and an internal probabilistic model checker for $\omega$-regular objectives. This functionality is modular and operates on shared data structures, which enables fast development of new translation techniques. Mungojerrie supports finite models specified in PRISM and $\omega$-automata specified in the HOA format, with an integrated command line interface to external linear temporal logic translators. Mungojerrie is distributed with a set of benchmarks for $\omega$-regular objectives in RL.",No,Maybe
,,,,,
122,TOOL,Verse: A Python library for reasoning about multi-agent hybrid system scenarios,"We present the Verse library with the aim of making hybrid system verification more usable for multi-agent scenarios. Multiple agents can be instantiated and they can be ported to different maps for creating scenarios. Verse provides functions for simulating and verifying such scenarios using existing reachability analysis algorithms. We illustrate several capabilities and use cases of Verse with heterogeneous agents, incremental verification, different sensor models and the flexibility of plugging in different subroutines for post computations.",No,Maybe
,,,,,
123,TOOL,Goose: A Meta-Solver for Deep Neural Network Verification,"The verification of deep neural networks is a recent algorithmic challenge that has attracted significant interest, resulting in a wide array of complete and incomplete solvers that draw on diverse techniques. As is typical in hard search problems, no single solver is expected to be the fastest on all inputs. While this insight has been leveraged to boost Boolean Satisfiability (SAT), for instance, by combining or tuning solvers, it is yet to lead to a leap in the neural network verification domain. Towards this goal, we present Goose, a meta-solver for deep neural network verification. Goose implements a variety of complete and incomplete subsolvers that get adaptively called based on information collected online and offline. Goose realizes this by implementing three synergizing strategies, namely, algorithm selection, probabilistic satisfiability inference, and time iterative deepening. We evaluate Goose by simulating VNN-COMP '21 and observe a 47.3% improvement over the competition winner in \partwo score across nearly 900 benchmarks and 13 solvers from the competition.",No,Maybe
,,,,,
124,TOOL,Carcara: An efficient proof checker and elaborator for SMT proofs in the Alethe forma,"Proofs from SMT solvers ensure correctness independently from implementation, which is often a requirement when solvers are used in safety-critical applications or proof assistants. Alethe is an established SMT proof format generated by the solvers veriT and cvc5, with reconstruction support in the proof assistants Isabelle/HOL and Coq. The format is close to SMT-LIB and allows both coarse- and fine-grained steps, facilitating proof production. However, it lacks a stand-alone checker, which hurts its usability and hinders its adoption. Moreover, the coarse-grained steps can be expensive to check and lead to verification failures. We present Carcara, an independent proof checker and elaborator for Alethe implemented in Rust. It aims to increase the adoption of the format by providing push-button proof-checking for Alethe proofs, focusing on efficiency and usability; and by providing elaboration for coarse-grained steps into fine-grained ones, increasing the potential success rate of checking Alethe proofs in performance-critical validators, such as proof assistants. We evaluate Carcara over a large set of Alethe proofs generated from SMT-LIB problems and show that it has good performance and its elaboration techniques can make proofs easier-to-check.",No,
,,,,,
128,TOOL,AbaHyper: Sound and Complete Model Checking for HyperLTL,"HyperLTL is a temporal logic that can express hyperproperties, i.e., properties that relate multiple execution traces of a system. Such properties are becoming increasingly important and naturally occur in information-flow control, robustness, fairness, mutation testing, and path planning. Thus far, sound-and-complete model checking tools for HyperLTL have been limited to alternation-free formulas, i.e., formulas that use only universal or only existential trace quantification. In this paper, we present AbaHyper, an explicit-state automata-based model checker that supports HyperLTL properties with arbitrary quantifier alternations and is sound and complete. We show that language inclusion checks can be integrated into HyperLTL verification, which allows AbaHyper to benefit from a range of existing inclusion-checking tools. We evaluate AbaHyper on a broad set of benchmarks drawn from different areas in the literature and compare with existing (incomplete) methods for HyperLTL verification. Our results show that, perhaps surprisingly, explicit-state model checking (as implemented in AbaHyper) often outperforms (incomplete) symbolic verification approaches.",No,Maybe
,,,,,
129,TOOL,ParaQooba: A Fast and Flexible Framework for Parallel and Distributed QBF Solving,"Over the last years, innovative parallel and distributed SAT solving techniques were presented that could impressively exploit the power of modern hardware and cloud systems. Two approaches were particularly successful: (1) search-space splitting in a Divide-and-Conquer (D&C) manner and (2) portfolio-based solving. The latter executes different solvers or configurations of solvers in parallel. For quantified Boolean formulas (QBFs), the extension of propositional logic with quantifiers, there is surprisingly little recent work in this direction compared to SAT.  In this paper, we present ParaQooba, a novel framework for parallel and distributed QBF solving which combines D&C parallelization and distribution with portfolio-based solving. Our framework is designed in such a way that it can be easily extended and arbitrary sequential QBF solvers can be integrated out of the box, without any programming effort. We show how ParaQooba orchestrates the collaboration of different solvers for joint problem solving by performing an extensive evaluation on benchmarks from QBFEval'22, the most recent QBF competition.",No,
,,,,,
150,TOOL,COOL 2 -- A Generic Reasoner for Modal Fixpoint Logics,"While the standard semantics of normal modal logics is based on relational structures such as Kripke frames or labelled transition systems, there is a wide range of modal logics beyond the relational spectrum. The semantics of such logics variously involves, for instance, probabilities, multi-player games, weights, or neighbourhood structures. Coalgebraic logic serves as a unifying semantic and algorithmic framework for such logics, and offers uniform reasoning algorithms that are easily instantiated to given modal logics. The COalgebraic Ontology Logic Solver (COOL) provides an implementation of these generic algorithms, along with a library of pre-instantiated logics. While the tool originally covered only next-step logics, version 2 as presented in the present paper offers support for highly expressive fixpoint logics within the coalgebraic µ-calculus. By instantiation, COOL 2 thus serves in particular as a reasoner for the graded µ-calculus and the alternating-time µ-calculus. The former requires the incorporation of recent generic algorithms based on one-step satisfiability checking (generalising algorithms that work with modal tableau rules). We evaluate the tool on standard benchmark sets for next-step graded modal logic as well as on a dedicated set of benchmarks for the graded µ-calculus.",No,
,,,,,
161,TOOL,Efficient and Verified Continuous Double Auctions,"Continuous double auctions are commonly used to match orders at currency, stock, and commodities exchanges. A verified implementation of continuous double auctions is a useful tool for market regulators as they give rise to automated checkers that are guaranteed to detect errors in the trade logs of an existing exchange if they contain trades that violate the matching rules. We provide an efficient and formally verified implementation of continuous double auctions that takes $O(n \log n)$ time to match $n$ orders. This improves an earlier $O(n^2)$ verified implementation. We also prove a matching $\Omega(n\log n)$ lower bound on the running time for continuous double auctions. Our new implementation takes only a couple of minutes to run on ten million randomly generated orders as opposed to a few days taken by the earlier implementation. We use the Coq proof assistant for verifying our implementation and extracting a verified OCaml program.",No,
,,,,,
163,TOOL,Bridging Hardware and Software Analysis with Btor2C: A Word-Level-Circuit-to-C Converter,"Across the broad field for the analysis of computational systems, research endeavors are often categorized by the respective models under investigation. Algorithms and tools are usually developed for a specific model, hindering their applications to similar problems originating from other computational systems. A prominent example of such situation is the studies on formal verification and testing for hardware and software systems. The two research communities share common theoretical foundations and terminologies, including satisfiability, interpolation, and abstraction refinement. Nevertheless, it is often demanding for one community to benefit from the advancements of the other, as analyzers typically assume a particular input format. To bridge the gap between the hardware and software analysis, we propose Btor2C, a converter from word-level sequential circuits to C programs. We choose the Btor2 language as the input format for its simplicity and bit-precise semantics. It can be deemed as an intermediate representation tailored for analysis. Upon a Btor2 circuit, Btor2C generates a behaviorally equivalent program in the C language, supported by most static program analyzers. We demonstrate the use cases of Btor2C by translating the benchmark set from the Hardware Model Checking Competitions into C programs and analyze them by tools from the Competitions on Software Verification and Testing. Our results show that software analyzers can complement hardware verifiers for enhanced quality assurance.",No,
,,,,,
166,TOOL,AIMOS: Metamorphic Testing of AI - An Industrial Application,"Despite initial fears of a renewed AI winter, the current summer seems to have no end in sight. AI in general and Deep Learning in particular are permeating a growing number of our daily applications with an undeniable added value. As with Computer Science itself, this increasing entanglement with our lives calls for a special attention to safety and demands adequate verification and validation methods and tools to assist in the development of reliable AI. In this paper, we present the AIMOS tool as well as the results of its application to industrial use-cases. Relying on the widely used Metamorphic testing paradigm, we show how the process of verification and validation can benefit from the early testing of models’ robustness to perturbations stemming from the intended operational domain.",No,Maybe
,,,,,
168,TOOL,DCModelChecker 2.0: A Tool for Two Dimensional Bounded Model Checking for Unbounded Petri Nets using LTL_LIA,"Bounded model checking (BMC) is an efficient formal verification technique which allows for desired properties of a software system to be checked on bounded runs of an abstract model of the system by querying a SAT/SMT solver. The properties are frequently described in a temporal logic and the system is modeled as a state transition system, in our case a Petri net. In this paper we propose a counting logic with linear integer arithmetic, called LTL_LIA, to describe the temporal properties of client-server systems with an unbounded number of clients and give its bounded semantics from which we derive its propositional encoding. We describe a SAT/SMT-based technique to check properties in LTL_LIA against runs of Petri net models. In this context, we propose an extension of BMC strategy, namely two-dimensional bounded model checking (2D-BMC), that uses two distinguishable parameters, one for execution steps and another for number of tokens in the net, and these two evolve separately. DCModelChecker 1.0 is a BMC tool to verify properties of a different counting logic for unbounded Petri nets. We extend their tool to verify properties of LTL_LIA and show the experimental results on DCModelChecker 2.0 for benchmarks from the Model Checking Contest (MCC).",No,